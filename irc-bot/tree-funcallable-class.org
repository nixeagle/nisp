#+TITLE: tree-funcallable-class.org
#+LINK: mop http://www.alu.org/mop/dictionary.html#%s
#+LINK: cl-net-project http://common-lisp.net/project/%s
#+LINK: asdf http://www.cliki.net/%s
#+LINK: cliki http://www.cliki.net/%s

This is my forth rewrite of nisp's command parsing system. In short the
routing system takes care of translating "github show foo" into terms
that lisp's [[ansi:generic-function][generic-function]] can handle and deal with. Commands are
structured like a tree, with each level having sub-nodes until a leaf is
reached. This leaf is what executes the behavior of the command.

* Prior attempts
  1) First attempt was a crude first pass that did not take advantage of
     the [[http://www.alu.org/mop/contents.html][Metaobject protocol]]. What I did was define
     =+command-routing-functions+= which contained an array of 16
     methods, each one taking one more command argument then the
     last. If the command was not a leaf, we simply went back and
     checked =+command-routing-functions+= again for another generic
     function with one more argument, repeating this cycle until we hit
     a leaf or until we failed to find a node or a leaf.[fn:1]
  2) My second attempt made use of the [[http://www.alu.org/mop/contents.html][Metaobject protocol]], but did not
     get very far or got close to being an acceptable replacement for
     =+command-routing-functions+=. What it did do was teach me about
     how the [[http://www.alu.org/mop/contents.html][Metaobject protocol]] really worked for selecting applicable
     methods. The functions and classes defined attempted to follow the
     examples given for [[mop:make-method-lambda]], focusing on figuring out
     how [[mop:call-next-method]] and [[mop:call-method]] interacted to pass an
     additional parameter to be used. With the extra parameter I defined
     =this-method=, which provided a pointer to the method class from
     inside of the function while it was called. A working example of
     this one is in a test case at [[file:tests.lisp::Testing%20the%20test%20generic%20function][test-gf test case]].
  3) The last attempt is at [[file:test-funcallable-class.lisp::defclass%20command%20generic%20function%20standard%20generic%20function][command-generic-function]]. This class and
     related specializer: [[file:test-funcallable-class.lisp::defclass%20command%20specializer%20specializer][command-specializer]] got to the point that a
     top level[fn:2] command could be recognized and called. However this did
     not handle all corner cases, and does not handle any levels below
     the top level.

* Current attempt
  The source will be at [[file:tree-funcallable-class.lisp]] and the tests
  will be at [[file:tree-funcallable-class-tests.lisp]].

  The dependencies will be the following:
  - [[cl-net-project:closer/closer-mop.html][closer/closer-mop.html]], [[http://common-lisp.net/project/closer/repos/closer-mop/][darcs repository]],
    [[cl-net-darcs-web:closer-mop][darcs web repository view]], [[asdf:closer-mop]]
  - [[cl-net-project:iterate][iterate]], [[cl-net-project:iterate/doc/index.html][manual]], [[cl-net-darcs-web:iterate][darcs web repository view]],
    [[asdf:iterate]]
  - [[cl-net-project:alexandria][alexandria]], [[cl-net-project:alexandria/draft/alexandria.pdf][manual]],  [[cl-net-project:alexandria/darcs/alexandria/][darcs repository]], [[asdf:alexandria]]

* MOP
  Our concept is making a generic function act like a network where each
  method can invoke [[ansi:call-next-method][call-next-method]] to traverse further down the tree as
  well as traverse laterally as in normal combinations.

*** Generic function call
***** compute-applicable-methods-using-classes
      For now we do not attempt to use this to do any sort of
      caching. Its one less thing to have a bug in at this time.

***** compute-applicable-methods
      Primary workhorse. Find all methods that have our tree-specializer
      in the first argument. Maybe at some point we can allow multiple
      trees to be specialized on at one time, but that might get
      computationally difficult and turn out to be a monster with too
      many heads to track.

******* preprocess-arglist
        Takes a [[ansi:generic-function][generic-function]] and the arglist as would be passed to
        [[*compute-applicable-methods]] and modifies the arglist into
        something that the standard applicable method computation can
        handle.

***** compute-effective-method
      Pick out which method is the one we want to start with.

*** Method definition
***** ensure-generic-function
***** ensure-generic-function-using-class
***** make-instance
      Especially note the keyword =:generic-function-class=
***** instance initialization
******* initialize-instance
******* reinitialize-instance
******* compute-discriminating-function
***** Build method function
******* make-method-lambda
***** Obtain method metaobject
******* make-instance
******* generic-function-method-class
******* initialize-instance
***** Add method to generic function
******* add-method
******* compute-discriminating-function
******* add-direct-method
* Dictionary
*** <<<tree-generic-function>>>
    Our special [[ansi:generic-function][generic-function]] class that has as its single superclass
    the class [[ansi:standard-generic-function][standard-generic-function]], and is itself a
    [[ansi:funcallable-standard-class][funcallable-standard-class]].

    Each [[ansi:generic-function][generic-function]] created using this class will contain an
    additional slot called top-level-tree that is the root for
    tree-specializer nodes.

*** <<<tree-specializer>>>
    This is a single node in a network with the root in
    tree-generic-function. This specializer contains a hash table that
    points to more tree-specializer nodes.

*** <<<tree-method>>>
    Right now not too much special about this one other then it is the
    default method-class for tree-generic-function objects.

* Footnotes

[fn:1] Failure to find a node or a leaf means there was no method
defined for that particular command.

[fn:2] Top level commands are things like =!github=, =!test=. These do
not have commands under them. Some examples of that are: =!github show=,
=!test run=, =!test run all= and so on.
